from datetime import datetime, timedelta
import pytz

def convert_to_local(utc_time_str, timezone_str):
    # Convert the string to a UTC datetime object
    utc_time = datetime.strptime(utc_time_str, "%Y-%m-%d %H:%M:%S.%f UTC")
    utc_time = utc_time.replace(tzinfo=pytz.UTC)
    
    # Convert to the local timezone
    local_timezone = pytz.timezone(timezone_str)
    local_time = utc_time.astimezone(local_timezone)
    
    # Print for debugging purposes
    print(f"UTC: {utc_time_str}, Local: {local_time}, Is DST: {bool(local_time.dst())}")
    
    return local_time

# Piecewise linear interpolation function
def piecewise_linear_interpolation(timestamps, interval_start, interval_end):
    uptime_minutes = 0
    downtime_minutes = 0
    
    for i in range(len(timestamps) - 1):
        start_time = timestamps[i][0]
        end_time = timestamps[i + 1][0]
        status = timestamps[i][1]
        
        # Calculate overlap with the interval
        overlap_start = max(start_time, interval_start)
        overlap_end = min(end_time, interval_end)
        
        if overlap_start < overlap_end:
            # Time interval
            interval_duration = (overlap_end - overlap_start).total_seconds() / 60
            
            # Debugging print
            print(f"Interval {overlap_start} to {overlap_end} ({interval_duration} minutes): Status = {status}")
            
            # Update uptime or downtime based on status
            if status == "active":
                uptime_minutes += interval_duration
            else:
                downtime_minutes += interval_duration
    
    return uptime_minutes, downtime_minutes


# Function to calculate uptime and downtime per hour
def calculate_uptime_downtime_per_period(timestamps, start_time, end_time):
    uptime = {}
    downtime = {}
    current_time = start_time
    
    while current_time < end_time:
        interval_start = current_time
        interval_end = current_time + timedelta(hours=1)
        
        uptime_minutes, downtime_minutes = piecewise_linear_interpolation(
            timestamps,
            interval_start,
            interval_end
        )
        
        hour_key = current_time.strftime('%Y-%m-%d %H:%M')
        uptime[hour_key] = uptime_minutes
        downtime[hour_key] = downtime_minutes
        
        current_time += timedelta(hours=1)
    
    return uptime, downtime

def calculate_uptime_downtime_last_hour(timestamps, start_time):
    uptime = {}
    downtime = {}
    current_time = start_time
    
    interval_start = current_time
    interval_end = current_time + timedelta(hours=1)
        
    uptime_minutes, downtime_minutes = piecewise_linear_interpolation(
            timestamps,
            interval_start,
            interval_end
        )
        
    hour_key = current_time.strftime('%Y-%m-%d %H:%M')
    uptime[hour_key] = uptime_minutes
    downtime[hour_key] = downtime_minutes
        
    
    return uptime, downtime

# Sample timestamps
timestamps = [
    ("2023-01-18 08:28:11.199373 UTC", "active"),
    ("2023-01-18 09:33:31.224187 UTC", "active"),
    ("2023-01-18 10:50:42.387342 UTC", "active"),
    ("2023-01-18 11:22:28.470681 UTC", "active"),
    ("2023-01-18 11:38:15.41072 UTC", "active"),
    ("2023-01-18 13:14:10.276538 UTC", "active"),
    ("2023-01-18 14:00:33.485961 UTC", "active"),
    ("2023-01-18 14:04:14.637056 UTC", "active"),
    ("2023-01-18 14:16:40.553801 UTC", "active"),
    ("2023-01-18 14:21:32.506316 UTC", "active"),
    ("2023-01-18 15:29:23.531144 UTC", "active"),
    ("2023-01-18 16:10:47.297274 UTC", "active"),
    ("2023-01-18 17:48:52.836054 UTC", "inactive"),
    ("2023-01-18 18:20:12.374906 UTC", "active"),
    ("2023-01-18 19:46:54.293877 UTC", "active"),
    ("2023-01-18 20:13:11.426259 UTC", "inactive"),
    ("2023-01-18 21:06:01.559625 UTC", "active"),
    ("2023-01-18 23:21:06.120623 UTC", "active")
]

# Convert timestamps to local time (America/New_York)
store_timezone = 'America/New_York'
timestamps = [(convert_to_local(ts, store_timezone), status) for ts, status in timestamps]

# for ts, status in timestamps:
#     print(f"Original: {ts}, Converted: {convert_to_local(ts, store_timezone)}")


# Business hours (already in local time)
business_hours_start = datetime.strptime("2023-01-18 07:30:00", "%Y-%m-%d %H:%M:%S")
business_hours_end = datetime.strptime("2023-01-18 22:30:00", "%Y-%m-%d %H:%M:%S")

# Make business hours timezone-aware
timezone = pytz.timezone(store_timezone)
business_hours_start = timezone.localize(business_hours_start)
business_hours_end = timezone.localize(business_hours_end)

# Calculate uptime and downtime for each hour
uptime_per_hour, downtime_per_hour = calculate_uptime_downtime_per_period(
    timestamps, 
    business_hours_start, 
    business_hours_end
)

uptime_per_lasthour, downtime_per_lasthour = calculate_uptime_downtime_last_hour(
    timestamps, 
    business_hours_start
)
# Aggregate uptime for the whole day
total_uptime_hours = sum(uptime_per_hour.values()) / 60

print("Uptime last her (in minutes)", uptime_per_lasthour)
print("Uptime per hour (in minutes):", uptime_per_hour)
print("Downtime per hour (in minutes):", downtime_per_hour)
print("Total uptime for the day (in hours):", total_uptime_hours)



